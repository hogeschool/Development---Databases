{

module Lexer 

// Opens methods related to fslex.exe
open FSharp.Text.Lexing
open CompilerErrors
open GeneratorLanguage
open System

let lexeme lexbuf =
   LexBuffer<char>.LexemeString lexbuf
let newline (lexbuf : LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine

let range (lexbuf : LexBuffer<_>) = lexbuf.EndPos.Line + 1, lexbuf.EndPos.Column

}

// Regular expressions
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')
let digit = ['0'-'9']
let letter = ['a'-'z' 'A'-'Z']
let idBody = ['a'-'z' 'A'-'Z' '_' '0'-'9']
let date = digit+ '-' digit+ '-' digit+ 'T' digit+ ':' digit+ ':' digit+ '.' digit+ 'Z'


rule tokenstream = parse
| whitespace	{ tokenstream lexbuf }
| newline	{ newline lexbuf; tokenstream lexbuf }
| '(' { Parser.LPAR }
| ')' { Parser.RPAR }
| '[' { Parser.LRANGE }
| ']' { Parser.RRANGE } 
| ',' { Parser.COMMA }
| ';' { Parser.SEMICOLON }
| "table" { Parser.TABLE }
| "with" { Parser.WITH }
| "rows" { Parser.ROWS }
| ("integer" | "int") { Parser.TYPE_INTEGER }
| "varchar" { Parser.TYPE_VARCHAR }
| "text" { Parser.TYPE_TEXT }
| "date" { Parser.TYPE_DATE }
| "real" { Parser.TYPE_REAL }
| "boolean" { Parser.TYPE_BOOLEAN }
| "foreign" { Parser.FOREIGN }
| "primary" { Parser.PRIMARY }
| "key" { Parser.KEY }
| "references" { Parser.REFERENCES }
| "true" | "false" { Parser.BOOLEAN (Boolean.Parse(LexBuffer<_>.LexemeString lexbuf)) }
| date { Parser.DATE (LexBuffer<_>.LexemeString lexbuf) }
| ['-']?digit+   { Parser.INT (Int32.Parse(LexBuffer<_>.LexemeString lexbuf)) } 
| ['-']?digit+('.'digit+)?(['e''E']digit+)?   { Parser.DECIMAL (Double.Parse(LexBuffer<_>.LexemeString lexbuf)) }
| letter(idBody)*   {Parser.ID (LexBuffer<_>.LexemeString lexbuf)}
| "\'" [^'\'']* "\'" { let s = LexBuffer<_>.LexemeString lexbuf in Parser.STRING (s.Trim [|'\''|]) }
| eof   	{ Parser.EOF }
| _    		{ parseError ("Unexpected token " + LexBuffer<_>.LexemeString lexbuf) }
