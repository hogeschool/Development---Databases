%{
  open GeneratorLanguage 
%}


// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token <System.Int32> INT  
%token <System.Double> DECIMAL
%token <System.String> ID
%token <System.String> STRING
%token < bool > BOOLEAN
%token < string > DATE
%token TYPE_INTEGER TYPE_VARCHAR TYPE_TEXT TYPE_REAL TYPE_BOOLEAN TYPE_DATE

%token COMMA LPAR RPAR LRANGE RRANGE SEMICOLON
%token TABLE WITH ROWS FOREIGN PRIMARY KEY REFERENCES

%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < GeneratorLanguage.TableDefinition > start

%left COMMA SEMICOLON
%nonassoc TYPE_INTEGER TYPE_VARCHAR TYPE_TEXT TYPE_REAL TYPE_BOOLEAN TYPE_DATE
 
%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  
start: tableDefinition EOF { $1 }

sqlTypeRange:
| TYPE_INTEGER LRANGE INT COMMA INT RRANGE  { SQLType.Integer($3,$5) }
| TYPE_VARCHAR LRANGE INT COMMA INT RRANGE  { SQLType.Varchar($3,$5) }
| TYPE_REAL    LRANGE DECIMAL COMMA DECIMAL RRANGE  { SQLType.Real($3,$5) }
| TYPE_DATE    LRANGE INT COMMA INT RRANGE  { SQLType.Date($3,$5) }

columnDef:
| ID TYPE_TEXT INT { Column.Create($1,SQLType.Text $3) }
| ID TYPE_BOOLEAN { Column.Create($1,SQLType.Boolean) }
| ID sqlTypeRange { Column.Create($1,$2) }

columns:
| columnDef COMMA columns { $1 :: $3 }
| columnDef { [$1] }

idSeq:
| ID COMMA idSeq { $1 :: $3 }
| ID { [$1] }

foreignKey: 
  FOREIGN KEY LPAR idSeq RPAR REFERENCES ID { 
    let rawReferences = $4 |> List.map (fun x -> (x,""))
    $7,rawReferences
  }

foreignKeys:
| foreignKey COMMA foreignKeys { $1 :: $3 }
| foreignKey { [$1] }

foreignKeySeq:
| foreignKeys SEMICOLON { $1 } 
| { [] }


tableDefinition: 
  TABLE ID LPAR columns SEMICOLON foreignKeySeq PRIMARY KEY LPAR idSeq RPAR RPAR WITH ROWS INT {
    let fkMap = $6 |> Map.ofList
    TableDefinition.Create($2,$4,fkMap,$10,$15)
  }




